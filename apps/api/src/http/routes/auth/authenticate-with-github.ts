import * as z from "zod";
import type { FastifyInstance } from "fastify";
import type { ZodTypeProvider } from "fastify-type-provider-zod";
import { BadRequestError } from "../_errors/bad-request-error";
import { prisma } from "@/lib/prisma";
import { env } from "@saas/env";

export async function authenticateWithGithub(app: FastifyInstance) {
  app.withTypeProvider<ZodTypeProvider>().post(
    "/sessions/github",
    {
      schema: {
        tags: ["Auth"],
        summary: "Authenticate with GitHub",
        description:
          "Gets the temporary code generated by GitHub after authorization and returns GitHub's user data.",
        body: z.object({
          returnedAuthCode: z.string(),
        }),
        response: {
          201: z.object({
            token: z.string(),
          }),
        },
      },
    },
    async (request, reply) => {
      const { returnedAuthCode } = request.body;

      const githubOAuthURL = new URL(
        "https://github.com/login/oauth/access_token"
      );

      githubOAuthURL.searchParams.set("client_id", env.GITHUB_OAUTH_CLIENT_ID);
      githubOAuthURL.searchParams.set(
        "client_secret",
        env.GITHUB_OAUTH_CLIENT_SECRET
      );
      githubOAuthURL.searchParams.set(
        "redirect_uri",
        env.GITHUB_OAUTH_CLIENT_REDIRECT_URL
      );
      githubOAuthURL.searchParams.set("code", returnedAuthCode);

      const githubAccessTokenResponse = await fetch(githubOAuthURL, {
        method: "POST",
        headers: {
          Accept: "application/json",
        },
      });

      const githubAccessTokenData = await githubAccessTokenResponse.json();

      const { access_token: githubAccessToken } = z
        .object({
          access_token: z.string().optional(),
          token_type: z.literal("bearer").optional(),
          scope: z.string().optional(),
        })
        .parse(githubAccessTokenData);

      if (!githubAccessToken) {
        throw new BadRequestError("Invalid GitHub access token.");
      }

      const githubUserResponse = await fetch("https://api.github.com/user", {
        headers: {
          Authorization: `Bearer ${githubAccessToken}`,
        },
      });

      const githubUserData = await githubUserResponse.json();

      let {
        id: githubId,
        name,
        email,
        avatar_url: avatarUrl,
      } = z
        .object({
          id: z.number().int().transform(String),
          name: z.string().nullable(),
          email: z.email().nullable(),
          avatar_url: z.url(),
        })
        .parse(githubUserData);

      if (!email) {
        const githubUserEmailsResponse = await fetch(
          "https://api.github.com/user/emails",
          {
            headers: {
              Authorization: `Bearer ${githubAccessToken}`,
            },
          }
        );

        const githubUserEmailsData = await githubUserEmailsResponse.json();

        const emailsList = z
          .array(
            z.object({
              email: z.email(),
              verified: z.boolean(),
              primary: z.boolean(),
              visibility: z.union([
                z.literal("public"),
                z.literal("private"),
                z.literal(null),
              ]),
            })
          )
          .parse(githubUserEmailsData);

        const primaryEmail = emailsList.find((e) => e.primary)?.email;
        const primaryEmailVisibility = emailsList.find(
          (e) => e.primary
        )?.visibility;

        if (!primaryEmail) {
          throw new BadRequestError("GitHub account with no primary email.");
        }

        if (!primaryEmailVisibility) {
          throw new BadRequestError(
            "Please verify your GitHub email at their platform."
          );
        }

        email = primaryEmail;
      }

      const userWithSameEmail = await prisma.user.findUnique({
        where: {
          email,
        },
      });

      if (userWithSameEmail) {
        throw new BadRequestError("User with the same email already exists.");
      }

      const [, domain] = email.split("@");
      const autoJoinOrganization = await prisma.organization.findFirst({
        where: {
          domain,
          shouldAttachUsersByDomain: true,
        },
      });

      const newUser = await prisma.user.create({
        data: {
          name,
          email,
          avatarUrl,
          member_on: autoJoinOrganization
            ? {
                create: {
                  organizationId: autoJoinOrganization.id,
                },
              }
            : undefined,
        },
      });

      await prisma.account.create({
        data: {
          provider: "GITHUB",
          providerAccountId: githubId,
          userId: newUser.id,
        },
      });

      const token = await reply.jwtSign(
        {
          sub: newUser.id,
        },
        {
          sign: {
            expiresIn: "7d",
          },
        }
      );

      return reply.status(201).send({ token });
    }
  );
}
